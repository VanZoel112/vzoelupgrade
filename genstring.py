#!/usr/bin/env python3
"""
VBot Assistant Account String Session Generator
Generate session string for assistant account and auto-save to .env

This script is used ONCE during bot deployment to setup assistant account.
The generated session string will be used for voice chat streaming.

Author: Vzoel Fox's
"""

import asyncio
import sys
from pathlib import Path
from telethon import TelegramClient
from telethon.sessions import StringSession
from telethon.errors import PhoneCodeInvalidError, PhoneNumberInvalidError, SessionPasswordNeededError


def print_header():
    """Print welcome header"""
    print("\n" + "="*60)
    print("  VBot Assistant Account - String Session Generator")
    print("="*60)
    print("\nThis will generate a session string for assistant account.")
    print("The assistant account will be used to:")
    print("  - Join voice chats in groups")
    print("  - Stream audio/video when users use /play or /vplay")
    print("  - Handle all voice chat operations")
    print("\nIMPORTANT:")
    print("  - Use a DIFFERENT phone number from bot owner")
    print("  - This account will appear in voice chats")
    print("  - Session string = full account access (keep secret!)")
    print("="*60 + "\n")


def get_env_path():
    """Get .env file path"""
    env_path = Path(__file__).parent / ".env"
    return env_path


def read_env_file(env_path):
    """Read .env file and return lines"""
    if not env_path.exists():
        return []

    try:
        with open(env_path, 'r', encoding='utf-8') as f:
            return f.readlines()
    except Exception as e:
        print(f"Warning: Could not read .env file: {e}")
        return []


def write_env_file(env_path, session_string):
    """Write or update STRING_SESSION in .env file"""
    try:
        lines = read_env_file(env_path)

        # Check if STRING_SESSION already exists
        session_found = False
        new_lines = []

        for line in lines:
            if line.strip().startswith('STRING_SESSION='):
                # Replace existing STRING_SESSION
                new_lines.append(f'STRING_SESSION="{session_string}"\n')
                session_found = True
            else:
                new_lines.append(line)

        # If STRING_SESSION not found, append it
        if not session_found:
            if new_lines and not new_lines[-1].endswith('\n'):
                new_lines.append('\n')
            new_lines.append('\n# Assistant Account Session String (Auto-generated by genstring.py)\n')
            new_lines.append(f'STRING_SESSION="{session_string}"\n')

        # Write back to file
        with open(env_path, 'w', encoding='utf-8') as f:
            f.writelines(new_lines)

        return True
    except Exception as e:
        print(f"Error writing .env file: {e}")
        return False


async def generate_session():
    """Generate session string"""
    print_header()

    # Get API credentials
    print("Step 1/5: API Credentials")
    print("-" * 60)
    print("Get from: https://my.telegram.org")
    print()

    try:
        api_id = int(input("Enter your API ID: ").strip())
    except ValueError:
        print("Error: API ID must be a number!")
        return None

    api_hash = input("Enter your API Hash: ").strip()

    if not api_id or not api_hash:
        print("Error: API ID and API Hash are required!")
        return None

    print("\n✓ API credentials received")

    # Get phone number
    print("\nStep 2/5: Phone Number")
    print("-" * 60)
    print("Format: +628123456789 (with country code)")
    print()

    phone = input("Enter phone number: ").strip()

    if not phone:
        print("Error: Phone number is required!")
        return None

    print("\n✓ Phone number received")

    # Create client and start
    print("\nStep 3/5: Login to Telegram")
    print("-" * 60)

    try:
        client = TelegramClient(StringSession(), api_id, api_hash)

        print("Connecting to Telegram...")
        await client.connect()

        print("✓ Connected successfully!")
        print("\nSending OTP to", phone, "...")

        # Start will handle OTP and 2FA automatically
        await client.start(phone=phone)

        print("\n✓ Login successful!")

    except Exception as e:
        print(f"Error during login: {e}")
        try:
            await client.disconnect()
        except:
            pass
        return None

    # Get session string
    print("\nStep 4/5: Generating Session String")
    print("-" * 60)

    try:
        session_string = client.session.save()

        # Get user info
        me = await client.get_me()

        print("\n" + "="*60)
        print("  SESSION STRING GENERATED SUCCESSFULLY!")
        print("="*60)
        print(f"\nAccount Info:")
        print(f"  Name: {me.first_name}")
        if me.last_name:
            print(f"  Full Name: {me.first_name} {me.last_name}")
        print(f"  Username: @{me.username or 'no_username'}")
        print(f"  User ID: {me.id}")
        print(f"  Phone: {me.phone}")
        print("\n" + "="*60)

        await client.disconnect()

        return session_string

    except Exception as e:
        print(f"Error generating session string: {e}")
        try:
            await client.disconnect()
        except:
            pass
        return None


async def main():
    """Main function"""

    # Generate session string
    session_string = await generate_session()

    if not session_string:
        print("\n❌ Failed to generate session string!")
        print("\nPlease try again and make sure:")
        print("  - API ID and API Hash are correct")
        print("  - Phone number format is correct (+628123456789)")
        print("  - OTP code is entered correctly")
        print("  - 2FA password is correct (if enabled)")
        sys.exit(1)

    # Auto-save to .env
    print("\nStep 5/5: Saving to .env file")
    print("-" * 60)

    env_path = get_env_path()

    if write_env_file(env_path, session_string):
        print(f"✓ Session string saved to: {env_path}")
        print("\n" + "="*60)
        print("  SETUP COMPLETE!")
        print("="*60)
        print("\nThe assistant account is now configured!")
        print("\nNext steps:")
        print("  1. Make sure all other config in .env is correct")
        print("  2. Start the bot with: python main.py")
        print("\nThe assistant account will:")
        print("  - Automatically join voice chats when needed")
        print("  - Stream audio/video for /play and /vplay commands")
        print("\n⚠ IMPORTANT: Keep .env file SECRET!")
        print("   STRING_SESSION = full account access")
        print("="*60 + "\n")
    else:
        print("\n⚠ Warning: Could not save to .env file automatically")
        print("\nPlease manually add this to your .env file:")
        print("-" * 60)
        print(f'STRING_SESSION="{session_string}"')
        print("-" * 60 + "\n")

    # Also save to backup file
    try:
        backup_file = Path(__file__).parent / "string_session.txt"
        with open(backup_file, 'w', encoding='utf-8') as f:
            f.write(f"STRING_SESSION=\"{session_string}\"\n")
        print(f"✓ Backup saved to: {backup_file}")
    except:
        pass


if __name__ == "__main__":
    try:
        asyncio.run(main())
    except KeyboardInterrupt:
        print("\n\n❌ Cancelled by user")
        sys.exit(0)
    except Exception as e:
        print(f"\n❌ Unexpected error: {e}")
        import traceback
        traceback.print_exc()
        sys.exit(1)
